fun powers2 file =		
	let		
		fun antonis x n =
			let	
				fun powers x =
					let 
						fun maxpower x =
							let 
								fun assist y =
									if x >= y then assist (2*y)
									else y div 2
							in
								assist 1
							end
						
						fun assist 0 1 L = 0::L
						  |	assist 1 1 L = 1::L
						  |	assist w p L =
							if w >= p then assist (w-p) (p div 2) (1::L)
							else assist w (p div 2) (0::L)
					in
						assist x (maxpower x) []
					end
					
				val L = powers x

				fun reverse xs = 
					let 
						fun rev (nil, z) = z 
						  | rev (y::ys, z) = rev (ys, y::z) 
					in
						rev (xs, nil)
					end

				fun sum L =
					let
						fun sumhelp [] s = s
						  | sumhelp (a::L) s = sumhelp L (s+a)
					in
						sumhelp L 0
					end
				
		
		
		
				fun assist L1 L2 0 = (reverse L1)@L2
				  | assist [] [a] x = [a]
				  | assist [] (a::b::L) x =
						if b > 0 then assist [] ((a+2)::(b-1)::L) (x-1)
						else assist [a] (b::L) x
				  | assist L1 [a] x = []
				  | assist (c::L1) (a::b::L2) x =
						if b > 0 then assist L1 (c::(a+2)::(b-1)::L2) (x-1)
						else assist (a::c::L1) (b::L2) x
				  | assist L1 L2 x = []
				
				val y = (n-sum L)
				
				fun cutzeros (0::L) = cutzeros L
				  | cutzeros L = L
			in
				if y < 0 then []
				else reverse(cutzeros(reverse(assist [] L y)))
			end
		





		fun readInt input = Option.valOf (TextIO.scanStream (Int.scan StringCvt.DEC) input)
		
		val inStream = TextIO.openIn file
		
		val n = readInt inStream
		val _ = TextIO.inputLine inStream
		
		fun readonce s =
			let 
				val r = readInt inStream
				val m = readInt inStream
				val _ = TextIO.inputLine inStream
				fun printList xs = print(String.concatWith "," (map Int.toString xs))
				val _ = print("[")
				val _ = printList (antonis r m)
				val _ = print("]\n")
			in
				if s = 1 then ()
				else readonce (s-1)
			end
	in
		readonce n
	end;